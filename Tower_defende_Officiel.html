<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Tower Defense - Enhanced VFX Edition</title>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        /* Le fond du body devient un simple noir pour un meilleur contraste cosmique */
        body {
            font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
            background: #000000; 
            color:#f8fafc;
            display:flex; align-items:center; justify-content:center;
            min-height:100vh; padding:20px;
            overflow: hidden;
        }
        .screen { 
            display:none; 
            /* Garde un fond sombre et moderne pour les panneaux UI */
            background: linear-gradient(135deg, #0a111a 0%, #1e293b 100%);
            border-radius:20px; 
            padding:40px; 
            width:100%; 
            /* Max-width par d√©faut pour les menus */
            max-width:1300px; 
            box-shadow: 0 20px 60px rgba(0,0,0,0.8), 0 0 100px rgba(59,130,246,0.1);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .screen.active { display:flex; flex-direction:column; gap:24px; }

        /* Permet √† l'√©cran de jeu de s'√©tendre au-del√† de 1300px (pour la carte large) */
        #gameScreen {
            max-width: none; 
        }

        .menu-screen { text-align:center; }
        .menu-btn { 
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color:white; 
            padding:16px 32px; 
            border:none; 
            border-radius:12px; 
            cursor:pointer; 
            margin:10px; 
            font-weight:700; 
            font-size: 18px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(59,130,246,0.4);
        }
        .menu-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(59,130,246,0.6);
        }
        .menu-btn.back { 
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            box-shadow: 0 4px 15px rgba(100,116,139,0.4);
        }
        .game-container { width:100%; display:flex; flex-direction:column; gap:20px; }
        .game-content { display:flex; gap:20px; align-items:flex-start; }
        /* Rendre le fond HTML du Canvas transparent pour laisser le fond dessin√© appara√Ætre */
        #gameCanvas { 
            background: transparent; 
            border-radius:16px; 
            border:3px solid rgba(59,130,246,0.3); 
            display:block;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6), inset 0 0 100px rgba(59,130,246,0.05);
            /* Ajout pour une transition visuelle de taille */
            transition: width 0.4s ease, height 0.4s ease;
        }
        .sidebar { width:320px; min-width:280px; display:flex; flex-direction:column; gap:14px; }
        .panel { 
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            padding:16px; 
            border-radius:12px; 
            border:1px solid rgba(59,130,246,0.2);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .stat-grid { display:grid; grid-template-columns:1fr 1fr; gap:12px; }
        .stat { 
            padding:12px; 
            border-radius:10px; 
            text-align:center; 
            font-weight:700;
            transition: all 0.3s ease;
            background: rgba(15,23,42,0.6);
        }
        .stat.gold { 
            color:#f59e0b; 
            border:2px solid rgba(245,158,11,0.3); 
            box-shadow: 0 0 20px rgba(245,158,11,0.1);
        }
        .stat.lives { 
            color:#ef4444; 
            border:2px solid rgba(239,68,68,0.3);
            box-shadow: 0 0 20px rgba(239,68,68,0.1);
        }
        .stat.wave {
            color:#8b5cf6;
            border:2px solid rgba(139,92,246,0.3);
            box-shadow: 0 0 20px rgba(139,92,246,0.1);
        }
        .stat.enemies {
            color:#06b6d4;
            border:2px solid rgba(6,182,212,0.3);
            box-shadow: 0 0 20px rgba(6,182,212,0.1);
        }
        .btn { 
            padding:12px; 
            border-radius:10px; 
            border:none; 
            cursor:pointer; 
            font-weight:700;
            transition: all 0.3s ease;
        }
        .btn.wave { 
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color:white;
            box-shadow: 0 4px 15px rgba(239,68,68,0.4);
        }
        .btn.wave:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(239,68,68,0.6);
        }
        .btn.back { 
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            color:white;
        }
        #towerShop { display:flex; flex-direction:column; gap:10px; max-height:300px; overflow:auto; }
        .tower-buy-item { 
            display:flex; 
            align-items:center; 
            gap:12px; 
            padding:10px; 
            border-radius:10px; 
            cursor:pointer; 
            border:2px solid rgba(59,130,246,0.2);
            transition: all 0.3s ease;
            background: rgba(15,23,42,0.4);
        }
        .tower-buy-item:hover:not(.disabled) {
            border-color: #3b82f6;
            background: rgba(59,130,246,0.1);
            transform: translateX(4px);
        }
        .tower-buy-item.disabled { opacity:0.45; cursor:default; }
        .tower-buy-item.selected { 
            border-color:#3b82f6; 
            background:rgba(59,130,246,0.15);
            box-shadow: 0 0 20px rgba(59,130,246,0.3);
        }
        .upgrade-stats { 
            padding:10px; 
            border-radius:10px; 
            background:rgba(7,20,38,0.6); 
            font-size:13px;
            border: 1px solid rgba(59,130,246,0.2);
        }
        h1 {
            color:#3b82f6; 
            font-size:56px; 
            margin-bottom:10px;
            text-shadow: 0 0 30px rgba(59,130,246,0.5);
        }
        h3 {
            color:#3b82f6;
            text-shadow: 0 0 10px rgba(59,130,246,0.3);
        }
    </style>
</head>
<body>
    <div class="screen active" id="menuScreen">
        <div class="menu-screen">
            <h1>üè∞ Tower Defense VFX</h1>
            <p style="color:#94a3b8; margin-bottom:24px; font-size:18px;">D√©fends ton royaume avec des effets visuels spectaculaires !</p>
            <button class="menu-btn" onclick="showScreen('mapSelectionScreen')">üéÆ Nouvelle Partie</button>
            <button class="menu-btn back" onclick="showHelp()">üìñ Guide</button>
        </div>
    </div>

    <div class="screen" id="mapSelectionScreen" style="max-width:800px;">
        <h2 style="color:#3b82f6; text-align:center; margin-bottom:24px;">üó∫Ô∏è Choisir la Carte et la Taille</h2>
        
        <div id="mapSelectionContainer" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:20px; margin-bottom:30px;">
            </div>

        <div style="text-align:center; margin-top:20px;">
            <button class="menu-btn back" onclick="showScreen('menuScreen')">‚¨ÖÔ∏è Retour au Menu</button>
        </div>
    </div>
    <div class="screen" id="gameScreen">
        <div class="game-container">
            <div class="game-content">
                <canvas id="gameCanvas"></canvas>
                <div class="sidebar">
                    <div class="panel stat-grid">
                        <div class="stat gold">üí∞ Or: <span id="gold">0</span></div>
                        <div class="stat lives">‚ù§Ô∏è Vie: <span id="lives">0</span></div>
                        <div class="stat wave">üåä Vague: <span id="wave">0</span></div>
                        <div class="stat enemies">üëπ Restants: <span id="enemies-remaining">0</span></div>
                    </div>

                    <div class="panel">
                        <h3 style="margin-bottom:10px;">üõ†Ô∏è Placer une Tour</h3>
                        <div id="towerShop"></div>
                        <p id="buyMessage" style="color:#f87171; font-weight:700; margin-top:10px; display:none;">üö´ Achat d√©sactiv√© pendant la vague.</p>
                    </div>

                    <div class="panel" id="upgradePanel" style="display:none;">
                        <h3>‚ú® Am√©lioration</h3>
                        <div id="towerDetails"></div>
                        <div style="margin-top:10px; display:flex; gap:10px;">
                            <button class="btn" id="upgradeButton" onclick="upgradeSelectedTower()" style="flex:1; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color:white;">Am√©liorer</button>
                            <button class="btn back" onclick="sellSelectedTower()" style="flex:1; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color:white;">Vendre</button>
                        </div>
                    </div>

                    <div class="panel" style="display:flex; gap:10px; justify-content:space-between;">
                        <button class="btn wave" id="waveButton" onclick="startWave()" style="flex:1;">üöÄ Lancer la vague</button>
                        <button class="btn back" onclick="showScreen('menuScreen')">üö™ Menu</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
/* ------------------------
   VARIABLES & CONFIG
   ------------------------ */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// NOUVEAU: D√©finition des dimensions de la carte
const MAP_DIMENSIONS = {
    small: { width: 900, height: 650 },
    medium: { width: 1050, height: 750 },
    large: { width: 1200, height: 800 }
};

// Variables de dimensions dynamiques
let MAP_WIDTH = MAP_DIMENSIONS.small.width;
let MAP_HEIGHT = MAP_DIMENSIONS.small.height;

// Initialisation du canvas avec la taille par d√©faut
canvas.width = MAP_WIDTH;
canvas.height = MAP_HEIGHT;

let gold = 0;
let lives = 0;
let wave = 0;
let towers = [];
let enemies = [];
let projectiles = [];
let particles = [];
let waveInProgress = false;
let waveCooldown = false;
let selectedTowerType = null;
let selectedTower = null;
let canBuyTowers = true;

let _lastRenderedShopGold = null;
let _lastRenderedShopCanBuy = null;

// VARIABLES et CLASSE pour le fond ESPACE anim√©
const NUM_STARS = 400;
let stars = [];
class Star {
    constructor() {
        // Les √©toiles sont g√©n√©r√©es en fonction des dimensions actuelles
        this.x = Math.random() * MAP_WIDTH;
        this.y = Math.random() * MAP_HEIGHT;
        this.size = Math.random() * 2 + 0.5;
        this.speed = Math.random() * 0.5 + 0.1;
        this.color = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.5})`;
        this.glow = Math.random() < 0.2; // 20% des √©toiles brillent
    }

    update() {
        this.x -= this.speed * (this.size / 2); // D√©placement lent vers la gauche
        if (this.x < 0) {
            this.x = MAP_WIDTH; // Se repositionne √† droite
            this.y = Math.random() * MAP_HEIGHT;
        }
    }

    draw() {
        if (this.glow) {
            ctx.shadowBlur = 5;
            ctx.shadowColor = 'white';
        }
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}
// FIN des variables et classe ESPACE

// CONFIGURATION DES CARTES (COORDONN√âES MISES √Ä JOUR POUR LES NOUVELLES TAILLES)
const mapConfigs = {
    plains: {
        name: "Plaines d'Azura", icon: "üåæ", 
        description: "Un parcours en 'S' avec un seul point de goulot d'√©tranglement.",
        paths: {
            small: [{x:0,y:150}, {x:250,y:150}, {x:250,y:520}, {x:600,y:520}, {x:600,y:250}, {x:900,y:250}],
            medium: [{x:0,y:150}, {x:300,y:150}, {x:300,y:600}, {x:750,y:600}, {x:750,y:250}, {x:450,y:250}, {x:450,y:500}, {x:1050,y:500}],
            large: [{x:0,y:100}, {x:200,y:100}, {x:200,y:700}, {x:950,y:700}, {x:950,y:150}, {x:400,y:150}, {x:400,y:550}, {x:1200,y:550}]
        }
    },
    trench: {
        name: "Tranch√©e de Crat√®re", icon: "üí£", 
        description: "Un parcours en spirale offrant de nombreuses opportunit√©s de d√©g√¢ts de zone.",
        paths: {
            small: [{x:0,y:325}, {x:150,y:325}, {x:150,y:100}, {x:750,y:100}, {x:750,y:550}, {x:50,y:550}, {x:50,y:250}, {x:900,y:250}],
            medium: [{x:0,y:375}, {x:100,y:375}, {x:100,y:50}, {x:950,y:50}, {x:950,y:700}, {x:50,y:700}, {x:50,y:150}, {x:800,y:150}, {x:800,y:600}, {x:1050,y:600}],
            large: [{x:0,y:400}, {x:50,y:400}, {x:50,y:50}, {x:1100,y:50}, {x:1100,y:750}, {x:50,y:750}, {x:50,y:100}, {x:1050,y:100}, {x:1050,y:700}, {x:150,y:700}, {x:150,y:200}, {x:1200,y:200}]
        }
    },
    asteroid: {
        name: "Ceinture d'Ast√©ro√Ødes", icon: "üåë", 
        description: "Des chemins courts et directs, la vitesse est essentielle.",
        paths: {
            small: [{x:0,y:100}, {x:450,y:100}, {x:450,y:550}, {x:900,y:550}],
            medium: [{x:0,y:50}, {x:750,y:50}, {x:750,y:400}, {x:250,y:400}, {x:250,y:700}, {x:1050,y:700}],
            large: [{x:0,y:100}, {x:400,y:100}, {x:400,y:50}, {x:1100,y:50}, {x:1100,y:750}, {x:50,y:750}, {x:50,y:250}, {x:1200,y:250}]
        }
    }
};

let selectedMapKey = 'plains';
let selectedMapSize = 'small';
let path = []; 

const PATH_WIDTH = 60;
const TOWER_RADIUS = 22;
const TOWER_MIN_DISTANCE_TO_PATH = PATH_WIDTH/2 + TOWER_RADIUS + 8;

const towerTypes = {
    // ... (Reste des configurations de tour inchang√©es)
    basic: { 
        maxLevel:3, cost:50, baseDamage:25, baseRange:130, baseFireRate:700, 
        color:'#4ade80', name:'Basique', icon:'üóº', desc:'√âquilibr√©e',
        projectileColor:'#4ade80',
        upgrades:{
            2:{cost:100, damageBonus:20, rangeBonus:40}, 
            3:{cost:200, damageBonus:30, rangeBonus:60, special:'Rapid Fire'}
        } 
    },
    sniper:{ 
        maxLevel:3, cost:150, baseDamage:100, baseRange:280, baseFireRate:1400, 
        color:'#f59e0b', name:'Sniper', icon:'üéØ', desc:'Longue port√©e',
        projectileColor:'#fbbf24',
        upgrades:{
            2:{cost:250, damageBonus:60, rangeBonus:60}, 
            3:{cost:400, damageBonus:80, rangeBonus:0, special:'Piercing', piercing:2}
        } 
    },
    splash:{ 
        maxLevel:3, cost:200, baseDamage:35, baseRange:110, baseFireRate:900, 
        splash:true, baseSplashRadius:70, color:'#8b5cf6', name:'Splash', icon:'üí•', desc:'D√©g√¢ts de zone',
        projectileColor:'#a78bfa',
        upgrades:{
            2:{cost:300, damageBonus:25, rangeBonus:25, splashRadiusBonus:25}, 
            3:{cost:500, damageBonus:40, splashRadiusBonus:50, special:'Mega Explosion'}
        } 
    },
    rapid:{ 
        maxLevel:3, cost:100, baseDamage:18, baseRange:120, baseFireRate:350, 
        color:'#06b6d4', name:'Rapide', icon:'‚ö°', desc:'Tir tr√®s rapide',
        projectileColor:'#22d3ee',
        upgrades:{
            2:{cost:150, damageBonus:12, rangeBonus:15}, 
            3:{cost:250, damageBonus:18, special:'Crit Chance', critChance:0.3}
        } 
    },
    ice:{ 
        maxLevel:3, cost:180, baseDamage:12, baseRange:150, baseFireRate:1100, 
        slow:true, slowAmount:0.5, color:'#3b82f6', name:'Glace', icon:'‚ùÑÔ∏è', desc:'Ralentit',
        projectileColor:'#60a5fa',
        upgrades:{
            2:{cost:200, damageBonus:12, rangeBonus:25, slowAmountBonus:0.15}, 
            3:{cost:350, damageBonus:20, special:'Freeze Chance', freezeChance:0.25}
        } 
    }
};

/* ------------------------
   CLASSES ET FONCTIONS (inchang√©)
   ------------------------ */

class Particle { /* ... */
    constructor(x, y, color, type='explosion') {
        this.x = x;
        this.y = y;
        this.type = type;
        this.lifetime = 0;
        this.maxLifetime = type === 'trail' ? 20 : 30;
        this.color = color;
        
        if(type === 'explosion') {
            this.vx = (Math.random() - 0.5) * 8;
            this.vy = (Math.random() - 0.5) * 8;
            this.size = Math.random() * 4 + 2;
        } else if(type === 'trail') {
            this.vx = (Math.random() - 0.5) * 2;
            this.vy = (Math.random() - 0.5) * 2;
            this.size = Math.random() * 3 + 1;
        } else if(type === 'hit') {
            this.vx = (Math.random() - 0.5) * 6;
            this.vy = (Math.random() - 0.5) * 6;
            this.size = Math.random() * 5 + 3;
        }
    }
    
    update() {
        this.lifetime++;
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.15; // gravity
        this.vx *= 0.98;
        return this.lifetime < this.maxLifetime;
    }
    
    draw() {
        const alpha = 1 - (this.lifetime / this.maxLifetime);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

function createExplosion(x, y, color, count=15) {
    for(let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, color, 'explosion'));
    }
}

function createHitEffect(x, y, color) {
    for(let i = 0; i < 8; i++) {
        particles.push(new Particle(x, y, color, 'hit'));
    }
}

function createTrail(x, y, color) {
    particles.push(new Particle(x, y, color, 'trail'));
}

class Tower { /* ... */
    constructor(x,y,type){
        this.x = x; this.y = y; this.type = type;
        this.props = towerTypes[type];
        this.level = 1;
        this.lastFire = 0;
        this.totalCost = this.props.cost;
        this.rotation = 0;
        this.targetRotation = 0;
        this.fireAnimation = 0;
    }
    
    getStat(base, name){
        let value = base;
        for(let i=2;i<=this.level;i++){
            const up = this.props.upgrades[i];
            if(!up) continue;
            value += up[`${name}Bonus`] || 0;
        }
        return value;
    }
    
    getDamage(){ return this.getStat(this.props.baseDamage,'damage'); }
    getRange(){ return this.getStat(this.props.baseRange,'range'); }
    getFireRate(){
        let fr = this.props.baseFireRate;
        for(let i=2;i<=this.level;i++){
            const up = this.props.upgrades[i];
            if(!up) continue;
            fr -= up.fireRatePenalty || 0;
        }
        return Math.max(100, fr);
    }
    getSplashRadius(){ return this.getStat(this.props.baseSplashRadius||0,'splashRadius'); }
    getSlowAmount(){ return this.getStat(this.props.slowAmount||0,'slowAmount'); }
    
    getSpecialAbility(){
        if(this.level<3) return null;
        const up = this.props.upgrades[3];
        if(!up) return null;
        if(up.piercing) return 'piercing';
        if(up.critChance) return 'critChance';
        if(up.freezeChance) return 'freezeChance';
        return null;
    }
    
    draw(){
        // Pulsating glow effect
        const pulseIntensity = 0.5 + Math.sin(Date.now() * 0.003) * 0.3;
        
        // Outer glow
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, TOWER_RADIUS * 2);
        gradient.addColorStop(0, hexWithAlpha(this.props.color, 0.3 * pulseIntensity));
        gradient.addColorStop(1, hexWithAlpha(this.props.color, 0));
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, TOWER_RADIUS * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Fire animation
        if(this.fireAnimation > 0) {
            ctx.save();
            ctx.globalAlpha = this.fireAnimation;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(this.x, this.y, TOWER_RADIUS * 1.5, 0, Math.PI * 2);
            ctx.fill();
            this.fireAnimation -= 0.1;
            ctx.restore();
        }
        
        // Tower body
        ctx.beginPath();
        ctx.arc(this.x, this.y, TOWER_RADIUS, 0, Math.PI * 2);
        const bodyGradient = ctx.createRadialGradient(this.x - 5, this.y - 5, 0, this.x, this.y, TOWER_RADIUS);
        bodyGradient.addColorStop(0, lightenColor(this.props.color, 30));
        bodyGradient.addColorStop(1, this.props.color);
        ctx.fillStyle = bodyGradient;
        ctx.fill();
        
        ctx.lineWidth = (selectedTower===this)?4:3;
        ctx.strokeStyle = (selectedTower===this)?'#fbbf24':'#ffffff';
        ctx.stroke();
        
        // Level indicator with glow
        if(this.level > 1) {
            for(let i = 0; i < this.level; i++) {
                const angle = (i / this.level) * Math.PI * 2 - Math.PI / 2;
                const px = this.x + Math.cos(angle) * (TOWER_RADIUS + 8);
                const py = this.y + Math.sin(angle) * (TOWER_RADIUS + 8);
                
                ctx.fillStyle = '#fbbf24';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#fbbf24';
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        // Icon
        ctx.fillStyle = '#000';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.props.icon, this.x, this.y);
        
        // Range indicator
        if(selectedTower===this){
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.getRange(), 0, Math.PI * 2);
            ctx.strokeStyle = hexWithAlpha(this.props.color, 0.4);
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    
    findTarget(){
        let best=null; let maxIndex=-1;
        for(const e of enemies){
            if(e.dead) continue;
            const d = Math.hypot(e.x - this.x, e.y - this.y);
            if(d <= this.getRange() && e.pathIndex > maxIndex){
                maxIndex = e.pathIndex; best = e;
            }
        }
        return best;
    }
    
    shoot(target){ 
        const now = Date.now(); 
        if(now - this.lastFire >= this.getFireRate()){ 
            projectiles.push(new Projectile(this.x, this.y, target, this)); 
            this.lastFire = now;
            this.fireAnimation = 1;
            
            // Calculate rotation to target
            const dx = target.x - this.x;
            const dy = target.y - this.y;
            this.targetRotation = Math.atan2(dy, dx);
        } 
    }
    
    update(){ 
        const t=this.findTarget(); 
        if(t) this.shoot(t);
        
        // Smooth rotation
        if(this.rotation !== this.targetRotation) {
            const diff = this.targetRotation - this.rotation;
            this.rotation += diff * 0.1;
        }
    }
}

class Projectile { /* ... */
    constructor(x,y,target,tower){
        this.x=x; this.y=y; this.target=target; this.tower=tower;
        this.damage = tower.getDamage(); 
        this.speed=12; 
        this.color=tower.props.projectileColor || tower.props.color;
        this.splash = tower.props.splash; 
        this.splashRadius = tower.getSplashRadius() || 0;
        this.slow = tower.props.slow; 
        this.slowAmount = tower.getSlowAmount() || 0;
        this.piercing = (tower.getSpecialAbility()==='piercing') ? tower.props.upgrades[3].piercing || 0 : 0;
        this.critChance = (tower.getSpecialAbility()==='critChance') ? tower.props.upgrades[3].critChance || 0 : 0;
        this.freezeChance = (tower.getSpecialAbility()==='freezeChance') ? tower.props.upgrades[3].freezeChance || 0 : 0;
        this.hits = [];
        this.trailCounter = 0;
    }
    
    applyHit(enemy){
        let finalDmg = this.damage;
        let isCrit = false;
        
        if(this.critChance > 0 && Math.random() < this.critChance) {
            finalDmg *= 2;
            isCrit = true;
        }
        
        const aliveAfter = enemy.takeDamage(finalDmg, isCrit);
        createHitEffect(enemy.x, enemy.y, this.color);
        
        if(!aliveAfter) return;
        if(this.slow) enemy.applySlowEffect(this.slowAmount);
        if(this.freezeChance>0 && Math.random() < this.freezeChance) enemy.applyFreezeEffect();
    }
    
    update(){
        // Trail effect
        this.trailCounter++;
        if(this.trailCounter % 2 === 0) {
            createTrail(this.x, this.y, this.color);
        }
        
        if(!this.target || this.target.dead){
            if(this.piercing > 0){
                const newT = enemies.find(e => !e.dead && !this.hits.includes(e));
                if(newT) this.target = newT; else return false;
            } else return false;
        }
        
        const dx = this.target.x - this.x, dy = this.target.y - this.y;
        const dist = Math.hypot(dx,dy);
        
        if(dist < this.speed + 8){
            if(this.splash){
                createExplosion(this.target.x, this.target.y, this.color, 25);
                if(!this.target.dead) this.applyHit(this.target);
                for(const e of enemies){
                    if(e===this.target || e.dead) continue;
                    if(Math.hypot(e.x - this.target.x, e.y - this.target.y) <= this.splashRadius) {
                        this.applyHit(e);
                    }
                }
                return false;
            } else {
                if(!this.target.dead){ 
                    this.applyHit(this.target); 
                    this.hits.push(this.target); 
                }
                if(this.piercing>0 && this.hits.length <= this.piercing){
                    const newT = enemies.find(e => !e.dead && !this.hits.includes(e) && Math.hypot(e.x - this.target.x, e.y - this.target.y) < 200);
                    if(newT){ this.target = newT; return true; }
                }
                return false;
            }
        } else {
            if(dist>0){ const ratio = this.speed/dist; this.x += dx*ratio; this.y += dy*ratio; }
            else return false;
        }
        return true;
    }
    
    draw(){ 
        // Glowing projectile
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.beginPath(); 
        ctx.arc(this.x, this.y, 6, 0, Math.PI*2); 
        ctx.fillStyle = this.color; 
        ctx.fill();
        
        // Inner bright core
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class Enemy { /* ... */
    constructor(wave){ 
        this.x=path[0].x; 
        this.y=path[0].y; 
        this.speed = 1.2 + wave*0.12; 
        this.maxHealth = 50 + wave*25; 
        this.health = this.maxHealth; 
        this.pathIndex=0; 
        this.dead=false; 
        this.slowTimer=0; 
        this.freezeTimer=0; 
        this.currentSlow=0;
        this.size = 12;
        this.rotation = 0;
        this.deathAnimation = 0;
    }
    
    takeDamage(dmg, isCrit=false){ 
        this.health -= dmg;
        
        // Show damage number
        if(isCrit) {
            createFloatingText(this.x, this.y, `-${Math.floor(dmg)}!`, '#ff0000', 24);
        } else {
            createFloatingText(this.x, this.y, `-${Math.floor(dmg)}`, '#ffffff', 18);
        }
        
        if(this.health <=0){ 
            this.dead=true; 
            gold += 10 + Math.floor(wave * 2);
            this.deathAnimation = 1;
            createExplosion(this.x, this.y, '#fef08a', 20);
            return false; 
        } 
        return true; 
    }
    
    applySlowEffect(amount){ this.slowTimer = 1200; this.currentSlow = amount; }
    applyFreezeEffect(){ this.freezeTimer = 600; }
    
    update(){
        if(this.dead) {
            if(this.deathAnimation > 0) {
                this.deathAnimation -= 0.05;
                this.rotation += 0.3;
                return;
            }
            return;
        }
        
        this.rotation += 0.05;
        
        let currentSpeed = this.speed;
        if(this.freezeTimer > 0){ 
            this.freezeTimer -= 16; 
            currentSpeed = 0;
            // Ice particles
            if(Math.random() < 0.3) {
                particles.push(new Particle(this.x + (Math.random()-0.5)*15, this.y + (Math.random()-0.5)*15, '#60a5fa', 'trail'));
            }
        }
        else if(this.slowTimer > 0){ 
            this.slowTimer -= 16; 
            currentSpeed *= (1 - this.currentSlow);
            if(Math.random() < 0.2) {
                particles.push(new Particle(this.x, this.y, '#3b82f6', 'trail'));
            }
        }
        
        if(this.pathIndex < path.length -1){
            const target = path[this.pathIndex+1];
            const dx = target.x - this.x, dy = target.y - this.y; 
            const dist = Math.hypot(dx,dy);
            if(dist <= currentSpeed){ 
                this.x = target.x; 
                this.y = target.y; 
                this.pathIndex++; 
            }
            else if(dist>0){ 
                const r = currentSpeed/dist; 
                this.x += dx*r; 
                this.y += dy*r; 
            }
        } else {
            this.dead = true; 
            lives--; 
            createExplosion(this.x, this.y, '#ef4444', 15);
            if(lives <= 0){ 
                setTimeout(() => {
                    alert('üíÄ GAME OVER ! Vague atteinte: ' + wave); 
                    showScreen('menuScreen');
                }, 100);
            }
        }
    }
    
    draw(){
        if(this.dead) {
            if(this.deathAnimation > 0) {
                ctx.save();
                ctx.globalAlpha = this.deathAnimation;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.scale(1 + (1 - this.deathAnimation), 1 + (1 - this.deathAnimation));
                
                // Enemy body
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fillStyle = '#fef08a';
                ctx.fill();
                
                ctx.restore();
            }
            return;
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        // Shadow
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.ellipse(0, 15, this.size, this.size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        
        // Glow effect
        const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size * 2);
        glowGradient.addColorStop(0, 'rgba(254, 240, 138, 0.4)');
        glowGradient.addColorStop(1, 'rgba(254, 240, 138, 0)');
        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(0, 0, this.size * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Enemy body with gradient
        const bodyGradient = ctx.createRadialGradient(-3, -3, 0, 0, 0, this.size);
        bodyGradient.addColorStop(0, '#fef9c3');
        bodyGradient.addColorStop(1, '#fef08a');
        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Border
        ctx.strokeStyle = '#854d0e';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Eyes
        ctx.fillStyle = '#dc2626';
        ctx.beginPath();
        ctx.arc(-4, -2, 2, 0, Math.PI * 2);
        ctx.arc(4, -2, 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        
        // Health bar with glow
        const hRatio = Math.max(0, this.health/this.maxHealth);
        const barWidth = this.size * 2.5;
        const barHeight = 5;
        const barX = this.x - barWidth / 2;
        const barY = this.y - this.size - 12;
        
        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Health with gradient
        const healthGradient = ctx.createLinearGradient(barX, 0, barX + barWidth * hRatio, 0);
        healthGradient.addColorStop(0, '#ef4444');
        healthGradient.addColorStop(1, '#22c55e');
        ctx.fillStyle = healthGradient;
        ctx.fillRect(barX, barY, barWidth * hRatio, barHeight);
        
        // Border
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        
        // Status effects
        if(this.freezeTimer > 0){ 
            ctx.font='18px Arial'; 
            ctx.fillStyle='#60a5fa';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#60a5fa';
            ctx.fillText('‚ùÑÔ∏è', this.x, this.y - this.size - 25); 
            ctx.shadowBlur = 0;
        }
        else if(this.slowTimer > 0){ 
            ctx.font='16px Arial'; 
            ctx.fillStyle='#3b82f6';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#3b82f6';
            ctx.fillText('üêå', this.x, this.y - this.size - 25); 
            ctx.shadowBlur = 0;
        }
    }
}

let floatingTexts = [];
class FloatingText { /* ... */
    constructor(x, y, text, color, size) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.size = size;
        this.lifetime = 0;
        this.maxLifetime = 60;
        this.vy = -2;
    }
    
    update() {
        this.lifetime++;
        this.y += this.vy;
        this.vy *= 0.95;
        return this.lifetime < this.maxLifetime;
    }
    
    draw() {
        const alpha = 1 - (this.lifetime / this.maxLifetime);
        ctx.globalAlpha = alpha;
        ctx.font = `bold ${this.size}px Arial`;
        ctx.fillStyle = this.color;
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 3;
        ctx.strokeText(this.text, this.x, this.y);
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1;
    }
}

function createFloatingText(x, y, text, color, size) {
    floatingTexts.push(new FloatingText(x, y, text, color, size));
}

function hexWithAlpha(hex, alpha){ /* ... */
    try {
        hex = hex.replace('#','');
        const r = parseInt(hex.substring(0,2),16);
        const g = parseInt(hex.substring(2,4),16);
        const b = parseInt(hex.substring(4,6),16);
        return `rgba(${r},${g},${b},${alpha})`;
    } catch(e){ return `rgba(255,255,255,${alpha})`; }
}

function lightenColor(hex, percent) { /* ... */
    hex = hex.replace('#', '');
    const num = parseInt(hex, 16);
    const r = Math.min(255, ((num >> 16) + percent));
    const g = Math.min(255, (((num >> 8) & 0x00FF) + percent));
    const b = Math.min(255, ((num & 0x0000FF) + percent));
    return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
}

/* ------------------------
   SELECTION DE CARTE
   ------------------------ */
function renderMapSelection(){
    const container = document.getElementById('mapSelectionContainer');
    container.innerHTML = '';

    for(const key in mapConfigs){
        const config = mapConfigs[key];
        const item = document.createElement('div');
        item.className = 'panel';
        item.style.cursor = 'pointer';
        item.style.border = `2px solid ${selectedMapKey === key ? '#3b82f6' : 'rgba(59,130,246,0.2)'}`;
        item.style.boxShadow = selectedMapKey === key ? '0 0 20px rgba(59,130,246,0.4)' : 'none';
        item.onclick = () => { selectedMapKey = key; selectedMapSize = 'small'; renderMapSelection(); };
        
        let sizeButtons = '';
        for(const size in config.paths){
            const isActive = selectedMapKey === key && selectedMapSize === size;
            sizeButtons += `
                <button 
                    class="btn menu-btn" 
                    style="padding: 8px 12px; font-size: 14px; margin: 4px 2px; 
                            background: ${isActive ? '#f59e0b' : '#334155'}; 
                            box-shadow: ${isActive ? '0 0 10px rgba(245,158,11,0.5)' : 'none'};"
                    onclick="event.stopPropagation(); selectedMapSize = '${size}'; selectedMapKey = '${key}'; renderMapSelection();"
                >
                    ${size.charAt(0).toUpperCase()}
                </button>`; // Affiche S, M, L
        }

        item.innerHTML = `
            <div style="font-size:24px; text-align:center;">${config.icon}</div>
            <h3 style="text-align:center; margin:5px 0 10px 0; color:#fff;">${config.name}</h3>
            <p style="font-size:13px; color:#94a3b8; margin-bottom:10px;">${config.description}</p>
            <div style="text-align:center;">${sizeButtons}</div>`;
            
        container.appendChild(item);
    }

    // G√®re le bouton de lancement
    let startBtn = document.getElementById('startGameFromSelection');
    if(!startBtn) {
        startBtn = document.createElement('button');
        startBtn.id = 'startGameFromSelection';
        startBtn.className = 'menu-btn';
        startBtn.onclick = startGame;
        document.getElementById('mapSelectionScreen').appendChild(startBtn);
    }
    startBtn.textContent = `Commencer la partie sur ${mapConfigs[selectedMapKey].name} (${selectedMapSize.toUpperCase()}) üöÄ`;
}

/* ------------------------
   INITIALISATION / UI
   ------------------------ */
function init(){
    // Initialisation des √©toiles
    for(let i = 0; i < NUM_STARS; i++) {
        stars.push(new Star());
    }
    
    // Initialisation de la s√©lection de carte
    renderMapSelection(); 
    
    showScreen('menuScreen');
    requestAnimationFrame(gameLoop);
}

function startGame(){
    // 1. Charger la configuration de la carte ET LA TAILLE
    const dims = MAP_DIMENSIONS[selectedMapSize];
    MAP_WIDTH = canvas.width = dims.width;
    MAP_HEIGHT = canvas.height = dims.height;
    
    path = mapConfigs[selectedMapKey].paths[selectedMapSize];

    // 2. R√©initialiser toutes les variables du jeu
    gold = 600; 
    lives = 25; 
    wave = 0;
    towers = []; 
    enemies = []; 
    projectiles = [];
    particles = [];
    floatingTexts = [];
    waveInProgress = false; 
    waveCooldown = false;
    selectedTowerType = null; 
    selectedTower = null; 
    canBuyTowers = true;
    _lastRenderedShopGold = null; 
    _lastRenderedShopCanBuy = null;
    
    // 3. Afficher l'√©cran de jeu
    updateUI();
    renderTowerShop(true);
    showScreen('gameScreen');
}

function showScreen(id){
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    
    // S'assurer que la s√©lection est rendue si on revient sur l'√©cran de s√©lection
    if(id === 'mapSelectionScreen') {
        renderMapSelection();
    }
}

function showHelp() {
    alert('üéÆ GUIDE DU JEU\n\n' +
          'üóº Tours disponibles:\n' +
          '‚Ä¢ Basique: √âquilibr√©e, bon choix pour d√©buter\n' +
          '‚Ä¢ Sniper: Longue port√©e, gros d√©g√¢ts, tir lent\n' +
          '‚Ä¢ Splash: D√©g√¢ts de zone, parfait pour les groupes\n' +
          '‚Ä¢ Rapide: Tir ultra-rapide, d√©g√¢ts mod√©r√©s\n' +
          '‚Ä¢ Glace: Ralentit et g√®le les ennemis\n\n' +
          '‚ú® Am√©liorations:\n' +
          '‚Ä¢ Niveau 2: Bonus de stats\n' +
          '‚Ä¢ Niveau 3: Capacit√© sp√©ciale unique\n\n' +
          'üí° Conseils:\n' +
          '‚Ä¢ Placez vos tours loin du chemin\n' +
          '‚Ä¢ Am√©liorez vos tours entre les vagues\n' +
          '‚Ä¢ Combinez diff√©rents types de tours\n' +
          '‚Ä¢ Les tours Splash sont efficaces dans les virages');
}

function updateUI(){
    document.getElementById('gold').textContent = gold;
    document.getElementById('lives').textContent = lives;
    document.getElementById('wave').textContent = wave;
    document.getElementById('enemies-remaining').textContent = enemies.filter(e=>!e.dead).length;
    
    const waveBtn = document.getElementById('waveButton');
    if(waveInProgress || waveCooldown){ 
        waveBtn.textContent = waveCooldown ? '‚è≥ Pr√©paration...' : '‚öîÔ∏è Combat en cours...'; 
        waveBtn.disabled = true; 
    } else { 
        waveBtn.disabled = false; 
        waveBtn.textContent = wave === 0 ? 'üöÄ Lancer la vague 1' : 'üöÄ Lancer la vague ' + (wave + 1); 
    }

    const buyMessage = document.getElementById('buyMessage');
    buyMessage.style.display = canBuyTowers ? 'none' : 'block';

    renderUpgradePanel();
    renderTowerShop();
}

/* ------------------------
   BOUTIQUE & ACHAT
   ------------------------ */
function renderTowerShop(force=false){ /* ... */
    const shopDiv = document.getElementById('towerShop');
    if(!force && _lastRenderedShopGold === gold && _lastRenderedShopCanBuy === canBuyTowers) return;
    _lastRenderedShopGold = gold; 
    _lastRenderedShopCanBuy = canBuyTowers;
    shopDiv.innerHTML = '';
    
    for(const type in towerTypes){
        const props = towerTypes[type];
        const canAfford = gold >= props.cost;
        const item = document.createElement('div');
        item.className = 'tower-buy-item';
        if(!canAfford) item.classList.add('disabled');
        if(selectedTowerType === type) item.classList.add('selected');

        item.innerHTML = `
            <div style="font-size:24px;">${props.icon}</div>
            <div style="flex:1;">
                <div style="font-weight:700; font-size:15px;">${props.name} 
                    <span style="font-weight:600; color:#94a3b8; font-size:11px;">(${props.desc})</span>
                </div>
                <div style="font-size:13px; color:#f59e0b; margin-top:2px;">
                    üí∞ ${props.cost} Or
                </div>
            </div>`;

        if(!canBuyTowers){
            item.onclick = () => alert('‚öîÔ∏è Achat d√©sactiv√© pendant la vague.');
        } else {
            item.onclick = () => {
                if(!canAfford){
                    alert('üí∞ Tu n\'as pas assez d\'or pour acheter cette tour maintenant.');
                    return;
                }
                selectTowerForPlacement(type);
            };
        }
        shopDiv.appendChild(item);
    }
}

function selectTowerForPlacement(type){
    if(selectedTowerType === type) {
        selectedTowerType = null;
    } else { 
        selectedTowerType = type; 
        selectedTower = null; 
    }
    canvas.style.cursor = selectedTowerType ? 'crosshair' : 'default';
    renderTowerShop(true);
    renderUpgradePanel();
}

function buyTower(type, x, y){
    const towerProps = towerTypes[type];
    if(!canBuyTowers){
        alert("‚öîÔ∏è L'achat de nouvelles tours est d√©sactiv√© pendant la vague.");
        return false;
    }
    if(gold >= towerProps.cost){
        towers.push(new Tower(x,y,type));
        gold -= towerProps.cost;
        selectedTowerType = null;
        canvas.style.cursor = 'default';
        createExplosion(x, y, towerProps.color, 20);
        updateUI();
        return true;
    } else {
        alert("üí∞ Pas assez d'or pour acheter cette tour.");
        selectedTowerType = null;
        canvas.style.cursor = 'default';
        updateUI();
        return false;
    }
}

/* ------------------------
   AMELIORATIONS & VENTE
   ------------------------ */
function renderUpgradePanel(){ /* ... */
    const panel = document.getElementById('upgradePanel');
    const details = document.getElementById('towerDetails');
    const upgradeBtn = document.getElementById('upgradeButton');
    
    if(!selectedTower){ 
        panel.style.display = 'none'; 
        return; 
    }
    
    panel.style.display = 'block';
    const t = selectedTower; 
    const p = t.props;
    const nextLevel = t.level + 1;
    const nextUpgrade = p.upgrades[nextLevel];
    
    let html = `
        <div style="font-weight:700; margin-bottom:10px; font-size:16px; color:#3b82f6;">
            ${p.icon} ${p.name} (Niveau ${t.level}/${p.maxLevel})
        </div>
        <div class="upgrade-stats">
            ‚öîÔ∏è D√©g√¢ts: <strong style="color:#22c55e;">${t.getDamage()}</strong><br>
            üéØ Port√©e: <strong style="color:#3b82f6;">${t.getRange()}</strong><br>
            ‚ö° Tir: <strong style="color:#f59e0b;">${t.getFireRate()} ms</strong><br>
            ${p.splash ? `üí• Splash: <strong style="color:#8b5cf6;">${t.getSplashRadius()}</strong><br>` : ''}
            ${p.slow ? `üêå Ralentit: <strong style="color:#06b6d4;">${Math.round(t.getSlowAmount()*100)}%</strong><br>` : ''}
            ${t.level === 3 && nextUpgrade?.special ? `‚ú® Sp√©cial: <strong style="color:#fbbf24;">${nextUpgrade.special}</strong><br>` : ''}
        </div>`;

    if(t.level >= p.maxLevel){
        html += `<div style="color:#22c55e; font-weight:700; margin-top:10px; text-align:center;">‚≠ê Niveau MAX atteint ‚≠ê</div>`;
        upgradeBtn.disabled = true;
    } else {
        const affordable = gold >= nextUpgrade.cost;
        html += `
            <div style="margin-top:10px; padding:8px; background:rgba(59,130,246,0.1); border-radius:8px; border:1px solid rgba(59,130,246,0.3);">
                <div style="font-weight:700; color:#3b82f6; margin-bottom:4px;">üîº Niveau ${nextLevel}</div>
                <div style="font-size:13px;">
                    üí∞ Co√ªt: <strong style="color:${affordable ? '#22c55e' : '#ef4444'};">${nextUpgrade.cost} Or</strong>
                </div>
                ${nextUpgrade.special ? `<div style="font-size:12px; color:#fbbf24; margin-top:4px;">‚ú® D√©bloque: ${nextUpgrade.special}</div>` : ''}
            </div>`;
        upgradeBtn.disabled = !affordable;
    }
    
    details.innerHTML = html;
}

function upgradeSelectedTower(){ /* ... */
    if(!selectedTower) return;
    const t = selectedTower;
    if(t.level >= t.props.maxLevel){ 
        alert('‚≠ê Cette tour est d√©j√† au niveau maximum !'); 
        return; 
    }
    const next = t.props.upgrades[t.level+1];
    if(gold >= next.cost){ 
        gold -= next.cost; 
        t.totalCost += next.cost; 
        t.level++;
        createExplosion(t.x, t.y, t.props.color, 30);
        createFloatingText(t.x, t.y - 40, 'NIVEAU ' + t.level + ' !', '#fbbf24', 20);
        updateUI(); 
    } else {
        alert('üí∞ Pas assez d\'or pour am√©liorer cette tour.');
    }
}

function sellSelectedTower(){ /* ... */
    if(!selectedTower) return;
    const sellAmount = Math.floor(selectedTower.totalCost * 0.6);
    gold += sellAmount;
    createExplosion(selectedTower.x, selectedTower.y, '#ef4444', 25);
    createFloatingText(selectedTower.x, selectedTower.y, '+' + sellAmount + ' üí∞', '#22c55e', 18);
    towers = towers.filter(t => t !== selectedTower);
    selectedTower = null;
    updateUI();
}

/* ------------------------
   VAGUES
   ------------------------ */
let enemySpawnInterval = null;
let enemiesToSpawn = 0;

function startWave(){
    if(waveInProgress) return;
    wave++;
    waveInProgress = true; 
    canBuyTowers = false;
    selectedTower = null; 
    selectedTowerType = null;
    // La difficult√© est mise √† l'√©chelle pour les cartes plus longues
    enemiesToSpawn = 12 + wave * 3 + (selectedMapSize === 'medium' ? 5 : selectedMapSize === 'large' ? 10 : 0);
    updateUI();
    enemySpawnInterval = setInterval(spawnEnemy, 700);
}

function spawnEnemy(){
    if(enemiesToSpawn > 0){ 
        enemies.push(new Enemy(wave)); 
        enemiesToSpawn--; 
        updateUI(); 
    } else { 
        clearInterval(enemySpawnInterval); 
        enemySpawnInterval = null; 
    }
}

function checkWaveEnd(){ /* ... */
    if(waveInProgress && enemiesToSpawn === 0 && enemies.filter(e=>!e.dead).length === 0){
        waveInProgress = false;
        const bonus = 120 + wave * 60 + (selectedMapSize === 'medium' ? 30 : selectedMapSize === 'large' ? 60 : 0);
        gold += bonus;
        canBuyTowers = true;
        waveCooldown = true;
        
        createFloatingText(MAP_WIDTH/2, MAP_HEIGHT/2, 'üéâ VAGUE TERMIN√âE !', '#22c55e', 32);
        createFloatingText(MAP_WIDTH/2, MAP_HEIGHT/2 + 40, '+' + bonus + ' üí∞', '#fbbf24', 24);
        
        updateUI();
        setTimeout(()=>{ 
            waveCooldown = false; 
            updateUI(); 
        }, 3500);
    }
}

/* ------------------------
   PLACEMENT / VALIDATION
   ------------------------ */
function isValidTowerPosition(x,y){
    if(x < TOWER_RADIUS + 5 || x > MAP_WIDTH - TOWER_RADIUS - 5 || 
       y < TOWER_RADIUS + 5 || y > MAP_HEIGHT - TOWER_RADIUS - 5) return false;
    
    for(const t of towers){ 
        if(Math.hypot(x - t.x, y - t.y) < TOWER_RADIUS * 2.2) return false; 
    }
    
    for(let i=0; i<path.length-1; i++){
        const p1 = path[i], p2 = path[i+1];
        const lenSq = (p2.x-p1.x)**2 + (p2.y-p1.y)**2;
        if(lenSq === 0) continue;
        let t = ((x-p1.x)*(p2.x-p1.x) + (y-p1.y)*(p2.y-p1.y))/lenSq;
        t = Math.max(0, Math.min(1, t));
        const closestX = p1.x + t*(p2.x-p1.x);
        const closestY = p1.y + t*(p2.y-p1.y);
        const distToSeg = Math.hypot(x - closestX, y - closestY);
        if(distToSeg < TOWER_MIN_DISTANCE_TO_PATH) return false;
    }
    return true;
}

/* ------------------------
   DESSIN PREVIEW
   ------------------------ */
function drawPlacementPreview(mouseX, mouseY){
    if(!selectedTowerType) return;
    const props = towerTypes[selectedTowerType];
    const range = props.baseRange;
    const cost = props.cost;
    const canPlace = isValidTowerPosition(mouseX, mouseY) && gold >= cost;
    
    // Animated range circle
    const pulseSize = range + Math.sin(Date.now() * 0.005) * 5;
    ctx.beginPath(); 
    ctx.arc(mouseX, mouseY, pulseSize, 0, Math.PI*2);
    ctx.fillStyle = canPlace ? 'rgba(66,255,66,0.08)' : 'rgba(255,66,66,0.08)'; 
    ctx.fill();
    ctx.strokeStyle = canPlace ? 'rgba(66,255,66,0.5)' : 'rgba(255,66,66,0.5)'; 
    ctx.lineWidth = 2; 
    ctx.setLineDash([10, 5]);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Tower preview with glow
    ctx.shadowBlur = 20;
    ctx.shadowColor = canPlace ? props.color : '#ef4444';
    ctx.beginPath(); 
    ctx.arc(mouseX, mouseY, TOWER_RADIUS, 0, Math.PI*2); 
    ctx.fillStyle = canPlace ? props.color : 'rgba(239,68,68,0.6)'; 
    ctx.fill();
    ctx.strokeStyle = '#fff'; 
    ctx.lineWidth = 3; 
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // Icon
    ctx.fillStyle = '#000'; 
    ctx.font = '20px Arial'; 
    ctx.textAlign='center'; 
    ctx.textBaseline = 'middle';
    ctx.fillText(props.icon, mouseX, mouseY);
    
    // Cost indicator
    ctx.font = 'bold 14px Arial';
    ctx.fillStyle = canPlace ? '#22c55e' : '#ef4444';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;
    ctx.strokeText(cost + ' üí∞', mouseX, mouseY + TOWER_RADIUS + 20);
    ctx.fillText(cost + ' üí∞', mouseX, mouseY + TOWER_RADIUS + 20);
}

/* ------------------------
   BACKGROUND EFFECTS (ESPACE)
   ------------------------ */
function drawBackground() {
    // Remplissage de l'espace avec un gradient cosmique sombre
    const gradient = ctx.createLinearGradient(0, 0, MAP_WIDTH, MAP_HEIGHT);
    gradient.addColorStop(0, '#0a101d');
    gradient.addColorStop(0.5, '#151c2a');
    gradient.addColorStop(1, '#0a101d');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);
    
    // Animation et dessin des √©toiles (l√©ger d√©placement pour l'effet de parallaxe)
    stars.forEach(star => {
        star.update();
        star.draw();
    });
    
    // Ajout d'une n√©buleuse subtile (effet de balayage bleu/violet)
    const nebulaAlpha = 0.05; // Tr√®s faible opacit√©
    
    // N√©buleuse 1: Bleu
    ctx.globalAlpha = nebulaAlpha;
    const nebulaGradient1 = ctx.createRadialGradient(MAP_WIDTH * 0.2, MAP_HEIGHT * 0.8, 0, MAP_WIDTH * 0.2, MAP_HEIGHT * 0.8, 300);
    nebulaGradient1.addColorStop(0, 'rgba(59, 130, 246, 1)'); // Bleu clair
    nebulaGradient1.addColorStop(1, 'rgba(59, 130, 246, 0)');
    ctx.fillStyle = nebulaGradient1;
    ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);

    // N√©buleuse 2: Violet
    ctx.globalAlpha = nebulaAlpha * 0.8;
    const nebulaGradient2 = ctx.createRadialGradient(MAP_WIDTH * 0.9, MAP_HEIGHT * 0.1, 0, MAP_WIDTH * 0.9, MAP_HEIGHT * 0.1, 250);
    nebulaGradient2.addColorStop(0, 'rgba(139, 92, 246, 1)'); // Violet
    nebulaGradient2.addColorStop(1, 'rgba(139, 92, 246, 0)');
    ctx.fillStyle = nebulaGradient2;
    ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);
    
    ctx.globalAlpha = 1; // R√©tablir l'opacit√©
}

/* ------------------------
   BOUCLE DE JEU
   ------------------------ */
let lastTime = 0;
let lastMouseX = 0, lastMouseY = 0;

function gameLoop(timestamp){
    const delta = timestamp - lastTime; 
    lastTime = timestamp;
    
    // drawBackground g√®re maintenant le nettoyage et le dessin du fond espace
    drawBackground();
    
    // Draw path with glow
    if (path.length > 0) {
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#1e293b';
        ctx.beginPath();
        ctx.lineWidth = PATH_WIDTH; 
        ctx.lineCap='round'; 
        ctx.strokeStyle='#334155';
        ctx.moveTo(path[0].x, path[0].y);
        for(let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y);
        ctx.stroke();
        
        // Path border
        ctx.lineWidth = PATH_WIDTH + 4;
        ctx.strokeStyle = 'rgba(59,130,246,0.2)';
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        for(let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y);
        ctx.stroke();
        
        ctx.shadowBlur = 0;
        ctx.lineCap='butt'; 
        ctx.lineWidth=1;
    }

    // Update and draw game entities
    towers.forEach(t => t.update());
    enemies.forEach(e => e.update());
    projectiles = projectiles.filter(p => p.update());
    particles = particles.filter(p => p.update());
    floatingTexts = floatingTexts.filter(t => t.update());

    towers.forEach(t => t.draw());
    projectiles.forEach(p => p.draw());
    enemies.forEach(e => e.draw());
    particles.forEach(p => p.draw());
    floatingTexts.forEach(t => t.draw());

    drawPlacementPreview(lastMouseX, lastMouseY);

    if(waveInProgress) checkWaveEnd();

    // Update UI
    document.getElementById('gold').textContent = gold;
    document.getElementById('lives').textContent = lives;
    document.getElementById('wave').textContent = wave;
    document.getElementById('enemies-remaining').textContent = enemies.filter(e=>!e.dead).length;

    requestAnimationFrame(gameLoop);
}

/* ------------------------
   EVENTS
   ------------------------ */
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    lastMouseX = e.clientX - rect.left;
    lastMouseY = e.clientY - rect.top;
});

canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;
    lastMouseX = clickX; 
    lastMouseY = clickY;

    if(selectedTowerType && canBuyTowers){
        if(isValidTowerPosition(clickX, clickY)) {
            buyTower(selectedTowerType, clickX, clickY);
        } else {
            alert('‚ùå Placement invalide: trop pr√®s du chemin ou d\'une autre tour.');
            selectedTowerType = null;
            canvas.style.cursor = 'default';
            renderTowerShop(true);
        }
    } else {
        let hit = null;
        for(const t of towers){
            if(Math.hypot(clickX - t.x, clickY - t.y) < TOWER_RADIUS) { 
                hit = t; 
                break; 
            }
        }
        if(hit){
            if(selectedTower === hit) selectedTower = null;
            else selectExistingTower(hit);
        } else {
            selectedTower = null; 
            selectedTowerType = null; 
            canvas.style.cursor = 'default';
        }
        updateUI();
    }
});

function selectExistingTower(t){
    selectedTower = t; 
    selectedTowerType = null; 
    canvas.style.cursor = 'default';
    renderTowerShop(true); 
    renderUpgradePanel();
}

/* ------------------------
   KEYBOARD SHORTCUTS
   ------------------------ */
document.addEventListener('keydown', (e) => {
    // Escape to cancel selection
    if(e.key === 'Escape') {
        selectedTower = null;
        selectedTowerType = null;
        canvas.style.cursor = 'default';
        updateUI();
    }
    
    // Space to start wave
    if(e.key === ' ' && !waveInProgress && !waveCooldown) {
        e.preventDefault();
        startWave();
    }
    
    // Number keys to select towers (1-5)
    if(canBuyTowers && !waveInProgress) {
        const towerArray = Object.keys(towerTypes);
        const num = parseInt(e.key);
        if(num >= 1 && num <= towerArray.length) {
            const type = towerArray[num - 1];
            if(gold >= towerTypes[type].cost) {
                selectTowerForPlacement(type);
            }
        }
    }
    
    // U to upgrade selected tower
    if(e.key === 'u' || e.key === 'U') {
        if(selectedTower) {
            upgradeSelectedTower();
        }
    }
    
    // S to sell selected tower
    if(e.key === 's' || e.key === 'S') {
        if(selectedTower) {
            sellSelectedTower();
        }
    }
});

/* ------------------------
   CANVAS LEAVE HANDLER
   ------------------------ */
canvas.addEventListener('mouseleave', () => {
    lastMouseX = -100;
    lastMouseY = -100;
});

/* ------------------------
   INITIALIZE
   ------------------------ */
window.onload = init;

</script>
</body>
</html>